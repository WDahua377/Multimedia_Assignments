## 方法描述： 
演算法描述：Spatial filtering 是透過數學方法 convolution 改變圖片裡的像素，達到讓優化影像或是加上特殊效果的功能。方法是按照不同濾鏡的 convolution mask 加權鄰近的像素，輸出最中間的像素結果，依序從圖片的左上到右下改變每⼀個像素。若遇上邊緣，可以選擇補 0 或是複製圖片邊緣的像素等方法解決，這次實作是以在邊緣補 0 的方式處理。

### 程式實作方法：
1. 先讀取照片”柴犬飛飛.jpg”，保留原矩陣，之後方便與輸出結果比較而得到 psnr 值，額外複製⼀個相同的矩陣，補 0 並專門用來計算，以下稱計算矩陣。 
2. 宣告⼀個填滿 0 的矩陣，將計算矩陣放在右下方擴充，給值回計算矩陣之後，計算矩陣的左上方擴充完畢。接下來直接將 0 矩陣加在右下方，以同樣的方式擴充，四周分別擴充 6 個像素，此時計算矩陣已經可以覆蓋最大 13\*13 的 mask 了。 
3. 開始計算 a1~a3、b1~b3、d_edge 與 d_unsharp，程式碼依據不同小題總共分成 8 部分，每部分的步驟幾乎相同。 
4. 首先，為了方便賦值，先宣告好儲存輸出結果的矩陣，大小都和原圖⼀樣是 640\*640\*3。 
5. 然後依據每題的要求設定好 mask (G矩陣)，使用 fspecial 函式得到不同 size 與 sigma 值的 gaussian mask，edge 和 unsharp 的部分則是直接賦予 G 矩陣內的值。 
6. 利用迴圈計算每⼀個 pixel，迴圈內先找出以該 pixel 為中心，附近受到 mask 覆蓋的範圍，將挑出來的範圍矩陣與 make 相乘，這裡使用1維矩陣相乘達到效果。 
7. 最後將覆蓋範圍內所有 pixel 的加權總和放進先前宣告好的矩陣內，當迴圈結束時，該矩陣便是最後的影像。 
8. a、b 小題的最後還需要計算 psnr 值，使用 psnr 函式將⼀開始儲存的原圖矩陣(沒有補 0 的)與最終影像對比，得到 psnr 值，印出計算結果並輸出圖片。 
9. 程式最後用 figure 與 imshow 顯示所有影像。

## 實驗數據、結果：
* 讀取照片：原先讀入的數據為 640\*640\*3 uint8 的矩陣，由於之後的計算都需要轉為 double，而 psnr 函數要求輸入的資料形式必須相同，因此統⼀使用 im2double 將所有影像轉為範圍 0~1 的 double 矩陣。
* 最終執行結果：
  * a_1 的 psnr 值為：32.7918
  * a_2 的 psnr 值為：31.0031 
  * a_3 的 psnr 值為：30.9989 
  * b_1 的 psnr 值為：32.7918
  * b_2 的 psnr 值為：31.3396
  * b_3 的 psnr 值為：31.3384

## 結果討論：
* MSE：均方誤差，兩個 mxn 的數位影像 A、B 的 MSE 被定義為： $$MSE = \frac{1}{mn} \displaystyle\sum_{i=0}^{n-1} \sum_{j=0}^{m-1} \left( A(i,j) - B(i,j) \right) ^2$$
* psnr 值的意義：以分貝為單位，是一種以量化的方式計算影像失真的方法，定義如下： $$10*\log_{10} \left( \frac{MAX_I^2}{MSE} \right)$$，其中 $$MAX_I$$ 為訊號的最大強度。
* psnr大小關係（資料來源：維基百科）：
  * 50dB：代表壓縮後的圖像僅有些許非常小的誤差。
  * 30dB：人眼很難察覺壓縮後和原始影像的差異。
  * 20dB~30dB：人眼就可以察覺出圖像的差異。
  * 10dB~20dB：人眼還是可以用肉眼看出這個圖像原始的結構，且直觀上會判斷兩張圖像不存在很大的差異。
  * 10dB：人類很難用肉眼去判斷兩個圖像是否為相同，⼀個圖像是否為另⼀個圖像的壓縮結果。
* sigma值：sigma值越大則mask的分布越平均，中心pixel的加權變少，而影像會更加模糊。 
<div align = "center">
<img src = "https://github.com/WDahua377/Multimedia_Assignments/blob/main/convolution/sigma_image.jpg" width = 40%>
</div>

* mask 的 size 越大，受到周圍 pixel 影響的範圍就越大，影像也會變得更模糊。

## 問題討論
* 資料型態：⼀開始沒有統⼀全部存成 double 的形式，double 和 uint8 混用，導致讀取照片後轉型了⼀次，計算完要填入值時再轉型⼀次，需要顯示照片時⼜要再轉，然而算了 psnr 值後才發現計算過程中將兩者混用會產生誤差，中間多花了很多時間了解每⼀個函式對資料型態的規定和改變計算方法。
* 看好作業規定： 其實前面最大的原因是沒是先看好作業規定，發現誤差去詢問同學之後才想到有些函式不能使用。由於起先是用 image 顯示圖片，所以用 double 函式轉型出來的矩陣無法顯示，才經歷了上述的好幾次轉型。後來發現這兩個函式都不在可用範圍內，其實只要用規定裡面的那些函式，就不會有這麼多資料型態上的問題了。 
* 程式流程：讀出來的照片是 640\*640\*3 的矩陣，為了計算每⼀個 pixel 用了很大的 for 迴圈，總覺得可以有更好的方式，在過程中也試圖想找出可以將過程處理地更簡單、更省時的辦法，但所有處理流程到最後還是沒有讓我很滿意，更了解 matlab 以後也許會有些新想法。
