## 方法描述
演算法描述：用 Nearest Neighbor Classification 進行人臉辨識，將 test 資料與 training 資料做比對，計算出最小的差別，並將 test 資料與該筆資料歸
類為同一人。 
### 程式實作方法：
1. 第一筆 training 資料讀進來，存在 allPic 陣列裡，隨後從 file 的 struct 中存取每筆 filename，使用 filename 依序將讀進來，將 矩陣轉成一行後放在原 allPic 矩陣後方，for 迴圈全部結束可以得到所有的 training 資料。
2. 接著輸入測試的照片，用一樣的方法將測試照片放在 test_file 裡面，進入 sad 計算的函式。
3. sad 函式裡，先將最小值與歸類編號( who 變數)設為第一筆 training 資料的結果。sad的計算方法是將照片內每個數據相減後取絕對值，將所有取完絕對值的差相加，得到兩張照片的差異數據，再尋找出最小值並記錄。
4. 回到測試照片的 for 迴圈裡檢查結果是否正確，此時的 who 變數記錄的是計算出來差異最小的照片編號，意思是該照片為資料庫中的第幾張，因為每個人有13張照片，所以將編號除以13後取 ceil 可以得到人的編號。i 記錄的是目前被測試的照片編號，而測試圖庫裡一樣是一個人13張，因此仍是除以13後取 ceil 得到人的編號。 
6. if 判斷兩者「人的編號」是否相同，相同則將正確結果總數加1，測試總數在 for 每一次迴圈結束前加1。
7. 最後將正確總數除以測試總數，其結果存在 A 變數，並在 command window 印出A的數值，也就是本次測試的準確率。
   
## 實驗數據、結果
* 輸入 training 數據階段：所有照片存在1287\*19800的 allPic 矩陣裡，也就是1287張從 training 資料夾中讀入165\*120的照片。
測試階段：寫入 test 照片，存在1\*19800的 test_file 裡。
* 計算階段：abs 函數不支援 uint8，因此轉為 double。
* 最終執行結果：準確率（正確分類的張數/所有的測試影像張數）約為67%。

## 結果討論
* 數據處理：如果將 uint8 數據直接放到 abs 函數裡，準確率會降低很多，以此為戒，可能需要檢查所有程式中用過的函數，確認每個數據的格式都正確之後，準確率可能可以因此再提高一些。 
* 計算方法：在不改變演算法的情況下改變計算方法，目前只有使用到 sad 方法，之後可以嘗試以 ssd 計算的話對準確值的影響會是什麼。 
* 照片品質：圍巾與墨鏡會增加判斷錯誤的機會。

## 問題討論
* 如何讀取大量圖片：對於一開始要怎麼將這麼多張照片讀進來感到很困擾，原本靠自己只想到複製1千多行程式碼，幸好後來上網查看到使用 dir 以 struct 的形式存取資料夾內的 file 資料。 
* 矩陣計算：由於之前沒接觸過 MATLAB，所以對於 MATLAB 中的函式以及存取矩陣的方法很陌生，花了一些時間了解、實作 MATLAB 的基礎操作。
